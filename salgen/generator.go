package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"strings"

	"reflect"

	"github.com/go-gad/sal/looker"
	"github.com/pkg/errors"
)

const (
	Prefix = "Sal"
)

type OperationType int

const (
	QueryRowOperation OperationType = iota
	QueryOperation
	ExecOperation
)

type generator struct {
	buf    bytes.Buffer
	indent string
}

func (g *generator) Generate(pkg *looker.Package, pkgName string) error {
	g.p("// Code generated by SalGen. DO NOT EDIT.")
	//g.p("// Generated at %s", time.Now())
	g.p("package %v", pkgName)

	g.p("import (")
	g.p("%q", "context")
	g.p("%q", pkg.ImportPath.Path)
	g.p("%q", "github.com/pkg/errors")
	g.p("%q", "github.com/go-gad/sal")
	g.p("%q", "database/sql")
	g.p(")")

	for _, intf := range pkg.Interfaces {
		if err := g.GenerateInterface(intf); err != nil {
			return err
		}
	}

	return nil
}

func (g *generator) GenerateInterface(intf *looker.Interface) error {
	implName := Prefix + intf.Name
	g.p("type %v struct {", implName)
	g.p("DBH sal.DBHandler")
	g.p("}")

	g.p("func New%v(dbh sal.DBHandler) *%v {", intf.Name, implName)
	g.p("return &%v{DBH: dbh}", implName)
	g.p("}")
	g.br()

	for _, mtd := range intf.Methods {
		if err := g.GenerateMethod(implName, mtd); err != nil {
			return err
		}
		g.br()
	}

	return nil
}

type prmArgs []string

func (pa prmArgs) String() string {
	return strings.Join(pa, ",")
}

func (g *generator) GenerateMethod(implName string, mtd *looker.Method) error {
	inArgs := make(prmArgs, 0, 2)
	inArgs = append(inArgs, "ctx "+mtd.In[0].Name())
	req := mtd.In[1]
	inArgs = append(inArgs, "req "+elementType(req.Pointer(), req.Name()))

	operation := calcOperationType(mtd.Out)

	outArgs := make(prmArgs, 0, 2)

	resp := mtd.Out[0]
	if operation != ExecOperation {
		outArgs = append(outArgs, elementType(resp.Pointer(), resp.Name()))
	}
	outArgs = append(outArgs, mtd.Out[len(mtd.Out)-1].Name())

	g.p("func (s *%v) %v(%v) (%v) {", implName, mtd.Name, inArgs.String(), outArgs.String())
	g.p("var reqMap = make(sal.RowMap)")

	if req.Kind() == reflect.Struct.String() {
		reqSt := req.(*looker.StructElement)
		for _, field := range reqSt.Fields {
			g.p("reqMap[%q] = &req.%s", field.ColumnName(), field.Name)
		}
		g.br()
		if reqSt.ProcessRower {
			g.p("req.ProcessRow(reqMap)")
			g.br()
		}
	} else {
		return errors.New("unsupported type of request variable")
	}

	g.p("pgQuery, args := sal.ProcessQueryAndArgs(req.Query(), reqMap)")
	g.br()

	switch operation {
	case QueryOperation, QueryRowOperation:
		g.p("rows, err := s.DBH.Query(pgQuery, args...)")
		g.ifErr("failed to execute Query")
		g.p("defer rows.Close()")
		g.br()

		g.p("cols, err := rows.Columns()")
		g.ifErr("failed to fetch columns")
		g.br()
	case ExecOperation:
		g.p("_, err := s.DBH.Exec(pgQuery, args...)")
		g.p("if err != nil {")
		g.p("return errors.Wrap(err, %q)", "failed to execute Exec")
		g.p("}")
		g.br()
	}

	if operation == ExecOperation {
		g.p("return nil")
		g.p("}")
		return nil
	}

	if operation == QueryRowOperation {
		g.p("if !rows.Next() {")
		g.p("if err := rows.Err(); err != nil {")
		g.p("return nil, errors.Wrap(err, %q)", "rows error")
		g.p("}")
		g.p("return nil, sql.ErrNoRows")
		g.p("}")
		g.br()
	}

	var respRow looker.Parameter
	if operation == QueryOperation {
		g.p("var list = make(%s, 0)", resp.Name())
		g.br()
		g.p("for rows.Next() {")
		respSlice := resp.(*looker.SliceElement)

		respRow = respSlice.Item
	} else {
		respRow = resp
	}
	var respRowStr = "resp"
	g.p("var %s %s", respRowStr, respRow.Name())
	g.p("var respMap = make(sal.RowMap)")
	if respRow.Kind() == reflect.Struct.String() {
		respSt := respRow.(*looker.StructElement)
		for _, field := range respSt.Fields {
			g.p("respMap[%q] = &resp.%s", field.ColumnName(), field.Name)
		}
		g.br()
		if respSt.ProcessRower {
			g.p("%s.ProcessRow(respMap)", respRowStr)
			g.br()
		}
	}
	g.p("var dest = make([]interface{}, 0, len(respMap))")
	g.p("for _, v := range cols {")
	g.p("if intr, ok := respMap[v]; ok {")
	g.p("dest = append(dest, intr)")
	g.p("}")
	g.p("}")
	g.br()

	g.p("if err = rows.Scan(dest...); err != nil {")
	g.p("return nil, errors.Wrap(err, %q)", "failed to scan row")
	g.p("}")
	if operation == QueryOperation {
		if respRow.Pointer() {
			respRowStr = "&resp"
		}
		g.br()
		g.p("list = append(list, %s)", respRowStr)
		g.p("}")
	}
	g.br()

	g.p("if err := rows.Err(); err != nil {")
	g.p("return nil, errors.Wrap(err, %q)", "something failed during iteration")
	g.p("}")
	g.br()

	respStr := "resp"
	if operation == QueryOperation {
		respStr = "list"
	}

	if resp.Pointer() {
		respStr = "&" + respStr
	}

	g.p("return %s, nil", respStr)
	g.p("}")

	return nil
}

func (g *generator) ifErr(msg string) {
	g.p("if err != nil {")
	g.p("return nil, errors.Wrap(err, %q)", msg)
	g.p("}")
}

func elementType(ptr bool, name string) string {
	var prefix string
	if ptr {
		prefix = "*"
	}
	return prefix + name
}

// Output returns the generator's output, formatted in the standard Go style.
func (g *generator) Output() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated source code: %s\n%s", err, g.buf.String())
	}
	return src
}

func (g *generator) p(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, g.indent+format+"\n", args...)
}

func (g *generator) br() {
	g.p("")
}

func calcOperationType(prms looker.Parameters) OperationType {
	if len(prms) == 1 {
		return ExecOperation
	}
	if prms[0].Kind() == reflect.Slice.String() {
		return QueryOperation
	}
	return QueryRowOperation
}
